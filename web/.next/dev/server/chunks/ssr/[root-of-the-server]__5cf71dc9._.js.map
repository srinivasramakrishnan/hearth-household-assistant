{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///Users/sramakrishna/Documents/Personal%20Projects/Bilbo/web/src/lib/firebase.ts"],"sourcesContent":["import { initializeApp } from \"firebase/app\";\nimport { getAuth } from \"firebase/auth\";\nimport { getFirestore } from \"firebase/firestore\";\nimport { getAnalytics } from \"firebase/analytics\";\n\n// These values will be filled in once we have the Firebase project setup\nconst firebaseConfig = {\n    apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\n    authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,\n    projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\n    storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\n    messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,\n    appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,\n    measurementId: process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID\n};\n\nconst app = initializeApp(firebaseConfig);\nexport const auth = getAuth(app);\nexport const db = getFirestore(app);\n\n// Initialize analytics only on client side to avoid SSR errors\nexport const analytics = typeof window !== \"undefined\" ? getAnalytics(app) : null;\n\nexport default app;\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;AAEA,yEAAyE;AACzE,MAAM,iBAAiB;IACnB,MAAM;IACN,UAAU;IACV,SAAS;IACT,aAAa;IACb,iBAAiB;IACjB,KAAK;IACL,aAAa;AACjB;AAEA,MAAM,MAAM,IAAA,iLAAa,EAAC;AACnB,MAAM,OAAO,IAAA,6KAAO,EAAC;AACrB,MAAM,KAAK,IAAA,iLAAY,EAAC;AAGxB,MAAM,YAAY,sCAAgC,0BAAoB;uCAE9D"}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///Users/sramakrishna/Documents/Personal%20Projects/Bilbo/web/src/context/AuthContext.tsx"],"sourcesContent":["\"use client\";\nimport { createContext, useContext, useEffect, useState } from 'react';\nimport { useAuthState } from 'react-firebase-hooks/auth';\nimport { auth, db } from '../lib/firebase';\nimport { doc, getDoc, setDoc, onSnapshot } from 'firebase/firestore';\nimport { UserProfile } from '../types';\nimport { User } from 'firebase/auth';\n\ninterface AuthContextType {\n    user: User | null | undefined;\n    appUser: UserProfile | null;\n    loading: boolean;\n    error: Error | undefined;\n    logout: () => Promise<void>;\n}\n\nconst AuthContext = createContext<AuthContextType>({\n    user: undefined,\n    appUser: null,\n    loading: true,\n    error: undefined,\n    logout: async () => { },\n});\n\nexport const AuthProvider = ({ children }: { children: React.ReactNode }) => {\n    const [user, loadingAuth, error] = useAuthState(auth);\n    const [appUser, setAppUser] = useState<UserProfile | null>(null);\n    const [loadingUser, setLoadingUser] = useState(false);\n\n    useEffect(() => {\n        let unsubscribe = () => { };\n\n        const syncUser = async () => {\n            if (!user) {\n                setAppUser(null);\n                setLoadingUser(false);\n                return;\n            }\n\n            setLoadingUser(true);\n            try {\n                const userRef = doc(db, 'users', user.uid);\n                unsubscribe = onSnapshot(userRef, async (snapshot) => {\n                    if (snapshot.exists()) {\n                        setAppUser({ uid: user.uid, ...snapshot.data() } as UserProfile);\n                    } else {\n                        // Create new user profile if logic requires it here, \n                        // matching previous App.tsx logic\n                        const newUser: UserProfile = {\n                            uid: user.uid,\n                            email: user.email,\n                            displayName: user.displayName,\n                            role: 'user',\n                            isApproved: false,\n                            preferences: {\n                                autoAddBackToShoppingList: true\n                            }\n                        };\n                        await setDoc(userRef, newUser);\n                    }\n                    setLoadingUser(false);\n                });\n            } catch (err) {\n                console.error(\"Error syncing user:\", err);\n                setLoadingUser(false);\n            }\n        };\n\n        syncUser();\n        return () => unsubscribe();\n    }, [user]);\n\n    const logout = async () => {\n        await auth.signOut();\n    };\n\n    const loading = loadingAuth || (!!user && loadingUser);\n\n    return (\n        <AuthContext.Provider value={{ user, appUser, loading, error, logout }}>\n            {children}\n        </AuthContext.Provider>\n    );\n};\n\nexport const useAuth = () => useContext(AuthContext);\n"],"names":[],"mappings":";;;;;;;AACA;AACA;AACA;AACA;AAAA;AAJA;;;;;;AAgBA,MAAM,4BAAc,IAAA,sNAAa,EAAkB;IAC/C,MAAM;IACN,SAAS;IACT,SAAS;IACT,OAAO;IACP,QAAQ,WAAc;AAC1B;AAEO,MAAM,eAAe,CAAC,EAAE,QAAQ,EAAiC;IACpE,MAAM,CAAC,MAAM,aAAa,MAAM,GAAG,IAAA,0LAAY,EAAC,8HAAI;IACpD,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,iNAAQ,EAAqB;IAC3D,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,iNAAQ,EAAC;IAE/C,IAAA,kNAAS,EAAC;QACN,IAAI,cAAc,KAAQ;QAE1B,MAAM,WAAW;YACb,IAAI,CAAC,MAAM;gBACP,WAAW;gBACX,eAAe;gBACf;YACJ;YAEA,eAAe;YACf,IAAI;gBACA,MAAM,UAAU,IAAA,wKAAG,EAAC,4HAAE,EAAE,SAAS,KAAK,GAAG;gBACzC,cAAc,IAAA,+KAAU,EAAC,SAAS,OAAO;oBACrC,IAAI,SAAS,MAAM,IAAI;wBACnB,WAAW;4BAAE,KAAK,KAAK,GAAG;4BAAE,GAAG,SAAS,IAAI,EAAE;wBAAC;oBACnD,OAAO;wBACH,sDAAsD;wBACtD,kCAAkC;wBAClC,MAAM,UAAuB;4BACzB,KAAK,KAAK,GAAG;4BACb,OAAO,KAAK,KAAK;4BACjB,aAAa,KAAK,WAAW;4BAC7B,MAAM;4BACN,YAAY;4BACZ,aAAa;gCACT,2BAA2B;4BAC/B;wBACJ;wBACA,MAAM,IAAA,2KAAM,EAAC,SAAS;oBAC1B;oBACA,eAAe;gBACnB;YACJ,EAAE,OAAO,KAAK;gBACV,QAAQ,KAAK,CAAC,uBAAuB;gBACrC,eAAe;YACnB;QACJ;QAEA;QACA,OAAO,IAAM;IACjB,GAAG;QAAC;KAAK;IAET,MAAM,SAAS;QACX,MAAM,8HAAI,CAAC,OAAO;IACtB;IAEA,MAAM,UAAU,eAAgB,CAAC,CAAC,QAAQ;IAE1C,qBACI,8OAAC,YAAY,QAAQ;QAAC,OAAO;YAAE;YAAM;YAAS;YAAS;YAAO;QAAO;kBAChE;;;;;;AAGb;AAEO,MAAM,UAAU,IAAM,IAAA,mNAAU,EAAC"}}]
}