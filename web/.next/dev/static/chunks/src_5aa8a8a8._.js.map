{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/sramakrishna/Documents/Personal%20Projects/Bilbo/web/src/lib/firebase.ts"],"sourcesContent":["import { initializeApp } from \"firebase/app\";\nimport { getAuth } from \"firebase/auth\";\nimport { getFirestore } from \"firebase/firestore\";\nimport { getAnalytics } from \"firebase/analytics\";\n\n// These values will be filled in once we have the Firebase project setup\nconst firebaseConfig = {\n    apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\n    authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,\n    projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\n    storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\n    messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,\n    appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,\n    measurementId: process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID\n};\n\nconst app = initializeApp(firebaseConfig);\nexport const auth = getAuth(app);\nexport const db = getFirestore(app);\n\n// Initialize analytics only on client side to avoid SSR errors\nexport const analytics = typeof window !== \"undefined\" ? getAnalytics(app) : null;\n\nexport default app;\n"],"names":[],"mappings":";;;;;;;;;;AAOY;AAPZ;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;;;;AAEA,yEAAyE;AACzE,MAAM,iBAAiB;IACnB,MAAM;IACN,UAAU;IACV,SAAS;IACT,aAAa;IACb,iBAAiB;IACjB,KAAK;IACL,aAAa;AACjB;AAEA,MAAM,MAAM,IAAA,oLAAa,EAAC;AACnB,MAAM,OAAO,IAAA,wKAAO,EAAC;AACrB,MAAM,KAAK,IAAA,kLAAY,EAAC;AAGxB,MAAM,YAAY,uCAAgC,IAAA,yLAAY,EAAC,OAAO;uCAE9D"}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///Users/sramakrishna/Documents/Personal%20Projects/Bilbo/web/src/context/AuthContext.tsx"],"sourcesContent":["\"use client\";\nimport { createContext, useContext, useEffect, useState } from 'react';\nimport { useAuthState } from 'react-firebase-hooks/auth';\nimport { auth, db } from '../lib/firebase';\nimport { doc, getDoc, setDoc, onSnapshot } from 'firebase/firestore';\nimport { UserProfile } from '../types';\nimport { User } from 'firebase/auth';\n\ninterface AuthContextType {\n    user: User | null | undefined;\n    appUser: UserProfile | null;\n    loading: boolean;\n    error: Error | undefined;\n    logout: () => Promise<void>;\n}\n\nconst AuthContext = createContext<AuthContextType>({\n    user: undefined,\n    appUser: null,\n    loading: true,\n    error: undefined,\n    logout: async () => { },\n});\n\nexport const AuthProvider = ({ children }: { children: React.ReactNode }) => {\n    const [user, loadingAuth, error] = useAuthState(auth);\n    const [appUser, setAppUser] = useState<UserProfile | null>(null);\n    const [loadingUser, setLoadingUser] = useState(false);\n\n    useEffect(() => {\n        let unsubscribe = () => { };\n\n        const syncUser = async () => {\n            if (!user) {\n                setAppUser(null);\n                setLoadingUser(false);\n                return;\n            }\n\n            setLoadingUser(true);\n            try {\n                const userRef = doc(db, 'users', user.uid);\n                unsubscribe = onSnapshot(userRef, async (snapshot) => {\n                    if (snapshot.exists()) {\n                        setAppUser({ uid: user.uid, ...snapshot.data() } as UserProfile);\n                    } else {\n                        // Create new user profile if logic requires it here, \n                        // matching previous App.tsx logic\n                        const newUser: UserProfile = {\n                            uid: user.uid,\n                            email: user.email,\n                            displayName: user.displayName,\n                            role: 'user',\n                            isApproved: false,\n                            preferences: {\n                                autoAddBackToShoppingList: true\n                            }\n                        };\n                        await setDoc(userRef, newUser);\n                    }\n                    setLoadingUser(false);\n                });\n            } catch (err) {\n                console.error(\"Error syncing user:\", err);\n                setLoadingUser(false);\n            }\n        };\n\n        syncUser();\n        return () => unsubscribe();\n    }, [user]);\n\n    const logout = async () => {\n        await auth.signOut();\n    };\n\n    const loading = loadingAuth || (!!user && loadingUser);\n\n    return (\n        <AuthContext.Provider value={{ user, appUser, loading, error, logout }}>\n            {children}\n        </AuthContext.Provider>\n    );\n};\n\nexport const useAuth = () => useContext(AuthContext);\n"],"names":[],"mappings":";;;;;;;AACA;AACA;AACA;AACA;AAAA;;;AAJA;;;;;AAgBA,MAAM,4BAAc,IAAA,8KAAa,EAAkB;IAC/C,MAAM;IACN,SAAS;IACT,SAAS;IACT,OAAO;IACP,QAAQ,WAAc;AAC1B;AAEO,MAAM,eAAe,CAAC,EAAE,QAAQ,EAAiC;;IACpE,MAAM,CAAC,MAAM,aAAa,MAAM,GAAG,IAAA,6LAAY,EAAC,iIAAI;IACpD,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAqB;IAC3D,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,yKAAQ,EAAC;IAE/C,IAAA,0KAAS;kCAAC;YACN,IAAI;sDAAc,KAAQ;;YAE1B,MAAM;mDAAW;oBACb,IAAI,CAAC,MAAM;wBACP,WAAW;wBACX,eAAe;wBACf;oBACJ;oBAEA,eAAe;oBACf,IAAI;wBACA,MAAM,UAAU,IAAA,yKAAG,EAAC,+HAAE,EAAE,SAAS,KAAK,GAAG;wBACzC,cAAc,IAAA,gLAAU,EAAC;+DAAS,OAAO;gCACrC,IAAI,SAAS,MAAM,IAAI;oCACnB,WAAW;wCAAE,KAAK,KAAK,GAAG;wCAAE,GAAG,SAAS,IAAI,EAAE;oCAAC;gCACnD,OAAO;oCACH,sDAAsD;oCACtD,kCAAkC;oCAClC,MAAM,UAAuB;wCACzB,KAAK,KAAK,GAAG;wCACb,OAAO,KAAK,KAAK;wCACjB,aAAa,KAAK,WAAW;wCAC7B,MAAM;wCACN,YAAY;wCACZ,aAAa;4CACT,2BAA2B;wCAC/B;oCACJ;oCACA,MAAM,IAAA,4KAAM,EAAC,SAAS;gCAC1B;gCACA,eAAe;4BACnB;;oBACJ,EAAE,OAAO,KAAK;wBACV,QAAQ,KAAK,CAAC,uBAAuB;wBACrC,eAAe;oBACnB;gBACJ;;YAEA;YACA;0CAAO,IAAM;;QACjB;iCAAG;QAAC;KAAK;IAET,MAAM,SAAS;QACX,MAAM,iIAAI,CAAC,OAAO;IACtB;IAEA,MAAM,UAAU,eAAgB,CAAC,CAAC,QAAQ;IAE1C,qBACI,6LAAC,YAAY,QAAQ;QAAC,OAAO;YAAE;YAAM;YAAS;YAAS;YAAO;QAAO;kBAChE;;;;;;AAGb;GA3Da;;QAC0B,6LAAY;;;KADtC;AA6DN,MAAM,UAAU;;IAAM,OAAA,IAAA,2KAAU,EAAC;AAAW;IAAtC"}}]
}